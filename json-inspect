#!/usr/bin/env python

## File: json-inspect
##
## Creates a histogram of field-values given a dot-delimited search path.
## Prints the output out in text.

import json
import math
import operator
import optparse
import os
import sys

from optparse import OptionParser


def main():
  usage = "json-histo [options] search [search [...]]"
  parser = OptionParser(usage=usage)

  parser.add_option('-p', '--prefix', dest='prefix', action='store',
                    help='String to prefix all search-paths with')
  parser.add_option('-f', '--file', dest='filename', action='store',
                    help='JSON file to read in. If not provided STDIN will be used')
  parser.add_option('-c', '--conflate', dest='conflate', action='store_true',
                    default=False, help='Conflate non-empty responses to the same value')

  (options, args) = parser.parse_args()

  _json = read_json(options.filename)
  if _json is None or len(_json) is 0:
    print("No file or STDIN provided")
    sys.exit(1)
    
  prefix = ''
  if options.prefix is not None:
    prefix = options.prefix
  search_paths = [prefix + a for a in args]

  for path in search_paths:
    matches = process_input(_json, path, options.conflate)
    print_histo(path, matches)

def print_histo(path, matches):
  """
  Given a histogram, print out the results using a 50 char width bar
  """
  print "\n{0}:".format(path)
  _max = max(matches.iteritems(), key=operator.itemgetter(1))[1]
  for k,v in matches.iteritems():
    percent_of_50 = int(math.ceil(50 * float(v) / float(_max)))
    print "{0:15s} | {1:50s} | ({2})".format(k[0:13], '#' * percent_of_50, v)

def process_input(json, path, conflate):
  """
  create a dict of metches. The keys in the dict are the JSON values at
  the specified path and the value is the count for the number of times
  the value was found. '__none__' is the key used for lookups that do
  not result in a value.
  
  json         - parsed JSON
  search_paths - array of search strings
  conflate     - bool flag to conflate positive values or not
  """
  results = {}

  search_tokens = path.split('.')
  search_stack = [json]
  next_stack = []
  for token in search_tokens:
    while search_stack:
      node = search_stack.pop()
      if token == '[]' and isinstance(node, list):
        for n in node:
          next_stack.append(n)
      elif token == '*' and isinstance(node, dict):
        for k,v in node.iteritems():
          next_stack.append(v)
      elif isinstance(node, dict):
        if node.get(token, None) is not None:
          next_stack.append(node.get(token))
        else:
          if '__none__' in results:
            results['__none__'] += 1
          else:
            results['__none__'] = 1

    search_stack = next_stack
    next_stack = []

  for res in search_stack:
    if conflate:
      res = '__some__'
    if str(res) in results:
      results[str(res)] += 1
    else:
      results[str(res)] = 1

  return results

def read_json(filename):
  """
  Read the file and parse it into JSON
  """
  _input = None
  if filename is None:
    _input = ''.join(sys.stdin)
  else:
    with open(filename, 'r') as f:
      _input = f.read()
  
  if _input is not None:
    return json.loads(_input)
  return f




if __name__ == '__main__':
  main()
